// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: domains.sql

package store

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const domainsCreate = `-- name: DomainsCreate :one
INSERT INTO domains (tenant_id, name, domain_type, source, status)
VALUES ($1, $2, $3, $4, $5)
ON CONFLICT (tenant_id, name)
    DO UPDATE SET updated_at = NOW()
RETURNING id, uid, name, domain_type, source, status
`

type DomainsCreateParams struct {
	TenantID   pgtype.Int4  `json:"tenant_id"`
	Name       string       `json:"name"`
	DomainType DomainType   `json:"domain_type"`
	Source     DomainSource `json:"source"`
	Status     DomainStatus `json:"status"`
}

type DomainsCreateRow struct {
	ID         int32        `json:"id"`
	Uid        string       `json:"uid"`
	Name       string       `json:"name"`
	DomainType DomainType   `json:"domain_type"`
	Source     DomainSource `json:"source"`
	Status     DomainStatus `json:"status"`
}

// Create a new domain (no auth)
func (q *Queries) DomainsCreate(ctx context.Context, arg DomainsCreateParams) (DomainsCreateRow, error) {
	row := q.db.QueryRow(ctx, domainsCreate,
		arg.TenantID,
		arg.Name,
		arg.DomainType,
		arg.Source,
		arg.Status,
	)
	var i DomainsCreateRow
	err := row.Scan(
		&i.ID,
		&i.Uid,
		&i.Name,
		&i.DomainType,
		&i.Source,
		&i.Status,
	)
	return i, err
}

const domainsDeleteByID = `-- name: DomainsDeleteByID :one
DELETE
FROM domains
WHERE id = $1
RETURNING id, uid, tenant_id, name, domain_type, source, status, created_at, updated_at
`

// Delete a domain (no auth)
func (q *Queries) DomainsDeleteByID(ctx context.Context, id int32) (Domains, error) {
	row := q.db.QueryRow(ctx, domainsDeleteByID, id)
	var i Domains
	err := row.Scan(
		&i.ID,
		&i.Uid,
		&i.TenantID,
		&i.Name,
		&i.DomainType,
		&i.Source,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const domainsGetAllRecordsByTenantID = `-- name: DomainsGetAllRecordsByTenantID :many
SELECT d.name,
       a.ipv4_address,
       aaaa.ipv6_address,
       mx.preference as mx_pref,
       mx.target     as mx_target,
       txt.value     as txt_record,
       ptr.target    as ptr_target,
       cname.target  as cname_target,
       ns.nameserver
FROM domains d
         LEFT JOIN a_records a ON d.id = a.domain_id
         LEFT JOIN aaaa_records aaaa ON d.id = aaaa.domain_id
         LEFT JOIN mx_records mx ON d.id = mx.domain_id
         LEFT JOIN txt_records txt ON d.id = txt.domain_id
         LEFT JOIN ptr_records ptr ON d.id = ptr.domain_id
         LEFT JOIN cname_records cname ON d.id = cname.domain_id
         LEFT JOIN ns_records ns ON d.id = ns.domain_id
WHERE d.tenant_id = $1
`

type DomainsGetAllRecordsByTenantIDRow struct {
	Name        string      `json:"name"`
	Ipv4Address pgtype.Text `json:"ipv4_address"`
	Ipv6Address pgtype.Text `json:"ipv6_address"`
	MxPref      pgtype.Int4 `json:"mx_pref"`
	MxTarget    pgtype.Text `json:"mx_target"`
	TxtRecord   pgtype.Text `json:"txt_record"`
	PtrTarget   pgtype.Text `json:"ptr_target"`
	CnameTarget pgtype.Text `json:"cname_target"`
	Nameserver  pgtype.Text `json:"nameserver"`
}

// Get domains with all their DNS records
// todo: add pagination
func (q *Queries) DomainsGetAllRecordsByTenantID(ctx context.Context, tenantID pgtype.Int4) ([]DomainsGetAllRecordsByTenantIDRow, error) {
	rows, err := q.db.Query(ctx, domainsGetAllRecordsByTenantID, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []DomainsGetAllRecordsByTenantIDRow{}
	for rows.Next() {
		var i DomainsGetAllRecordsByTenantIDRow
		if err := rows.Scan(
			&i.Name,
			&i.Ipv4Address,
			&i.Ipv6Address,
			&i.MxPref,
			&i.MxTarget,
			&i.TxtRecord,
			&i.PtrTarget,
			&i.CnameTarget,
			&i.Nameserver,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const domainsListAll = `-- name: DomainsListAll :many
SELECT id,
       uid,
       tenant_id,
       name,
       domain_type,
       source,
       status,
       created_at,
       updated_at
FROM domains
ORDER BY created_at DESC
`

// List all domains (no auth, for development/debugging only - avoid in production)
func (q *Queries) DomainsListAll(ctx context.Context) ([]Domains, error) {
	rows, err := q.db.Query(ctx, domainsListAll)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Domains{}
	for rows.Next() {
		var i Domains
		if err := rows.Scan(
			&i.ID,
			&i.Uid,
			&i.TenantID,
			&i.Name,
			&i.DomainType,
			&i.Source,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const domainsListByTenantID = `-- name: DomainsListByTenantID :many
SELECT id,
       uid,
       tenant_id,
       name,
       domain_type,
       source,
       status,
       created_at,
       updated_at
FROM domains
WHERE tenant_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type DomainsListByTenantIDParams struct {
	TenantID pgtype.Int4 `json:"tenant_id"`
	Limit    int32       `json:"limit"`
	Offset   int32       `json:"offset"`
}

// List all domains for a tenant with pagination (no auth)
func (q *Queries) DomainsListByTenantID(ctx context.Context, arg DomainsListByTenantIDParams) ([]Domains, error) {
	rows, err := q.db.Query(ctx, domainsListByTenantID, arg.TenantID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Domains{}
	for rows.Next() {
		var i Domains
		if err := rows.Scan(
			&i.ID,
			&i.Uid,
			&i.TenantID,
			&i.Name,
			&i.DomainType,
			&i.Source,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const domainsReadByID = `-- name: DomainsReadByID :one
SELECT id,
       uid,
       tenant_id,
       name,
       domain_type,
       source,
       status,
       created_at,
       updated_at
FROM domains
WHERE id = $1
`

func (q *Queries) DomainsReadByID(ctx context.Context, id int32) (Domains, error) {
	row := q.db.QueryRow(ctx, domainsReadByID, id)
	var i Domains
	err := row.Scan(
		&i.ID,
		&i.Uid,
		&i.TenantID,
		&i.Name,
		&i.DomainType,
		&i.Source,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const domainsReadByName = `-- name: DomainsReadByName :one
SELECT id,
       uid,
       tenant_id,
       name,
       domain_type,
       source,
       status,
       created_at,
       updated_at
FROM domains
WHERE tenant_id = $1
  AND name = $2
`

type DomainsReadByNameParams struct {
	TenantID pgtype.Int4 `json:"tenant_id"`
	Name     string      `json:"name"`
}

// Read a domain by name and tenant ID (no auth)
func (q *Queries) DomainsReadByName(ctx context.Context, arg DomainsReadByNameParams) (Domains, error) {
	row := q.db.QueryRow(ctx, domainsReadByName, arg.TenantID, arg.Name)
	var i Domains
	err := row.Scan(
		&i.ID,
		&i.Uid,
		&i.TenantID,
		&i.Name,
		&i.DomainType,
		&i.Source,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const domainsUpdateByID = `-- name: DomainsUpdateByID :one
UPDATE domains
SET status = $2
WHERE id = $1
RETURNING id, uid, tenant_id, name, domain_type, source, status, created_at, updated_at
`

type DomainsUpdateByIDParams struct {
	ID     int32        `json:"id"`
	Status DomainStatus `json:"status"`
}

// Update a domain's status (no auth)
func (q *Queries) DomainsUpdateByID(ctx context.Context, arg DomainsUpdateByIDParams) (Domains, error) {
	row := q.db.QueryRow(ctx, domainsUpdateByID, arg.ID, arg.Status)
	var i Domains
	err := row.Scan(
		&i.ID,
		&i.Uid,
		&i.TenantID,
		&i.Name,
		&i.DomainType,
		&i.Source,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const domainsUpdateByIDTypeSource = `-- name: DomainsUpdateByIDTypeSource :one
UPDATE domains
SET domain_type = $2,
    source      = $3
WHERE id = $1
RETURNING id, uid, tenant_id, name, domain_type, source, status, created_at, updated_at
`

type DomainsUpdateByIDTypeSourceParams struct {
	ID         int32        `json:"id"`
	DomainType DomainType   `json:"domain_type"`
	Source     DomainSource `json:"source"`
}

// Update a domain's type and source (no auth)
func (q *Queries) DomainsUpdateByIDTypeSource(ctx context.Context, arg DomainsUpdateByIDTypeSourceParams) (Domains, error) {
	row := q.db.QueryRow(ctx, domainsUpdateByIDTypeSource, arg.ID, arg.DomainType, arg.Source)
	var i Domains
	err := row.Scan(
		&i.ID,
		&i.Uid,
		&i.TenantID,
		&i.Name,
		&i.DomainType,
		&i.Source,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
